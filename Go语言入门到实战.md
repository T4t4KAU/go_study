## Go语言入门到实战

IDE: Goland

OS: Deepin Linux

#### 写在前面

先吹一波Go语言...

它是一种非常简单的语言，学习一周就可以编写一些简单、实用，而且质量不低的小程序。

它是生产力与性能的最佳结合。能在保持生产力的同时，大幅度提高性能。

它能给你带来快乐。相比C++，Go的开发体验有巨大提升。

现在来谈谈Go的历史和现状，毕竟这对我来说也是一门新语言，得对它有一个整体的认知。

Go的创始人有三位，分别是肯-汤普森(Unix之父)、罗伯-派克(UTF8编码设计者)和罗伯特-格瑞史莫。

由于当时谷歌内部主要使用C++语言构建各种系统，但C++的巨大复杂性、编译构建速度慢以及在编写服务端程序时对并发支持不足，让三位大佬感到不便。于是乎他们就想设计一门新的语言...

#### 认识Go程序的结构

用Go语言中编写一个可以打印"Hello World"的程序，只需要简单两步，一是创建文件夹，二是开始编写和运行。

首先创建一个文件夹存储编写的go代码

```shell
$ mkdir goprojects
$ cd goprojects/
$ mkdir helloworld
$ cd helloworld/
```

然后编写程序

在命名.go文件时不能使用下划线，有多个单词时直接将其连接起来就行了

```go
package main

import "fmt"

func main() {
        fmt.Println("Hello World")
}
```

```shell
$ go build main.go
$ ./main
Hello World
```

如上是命令行编译

现在回头看看结构

```go
package main
```

这一行代码定义了Go中的一个包package。包是Go语言的基本组成单元，通常使用单个的小写单词命名，一个Go程序本质上就是一组包的集合。所有Go代码都有自己隶属的包，在这里的"Hello World"示例的所有代码都在一个名为main的包中。main包在Go中是一个特殊的包，整个Go程序仅允许存在一个名为main的包

main包的主要代码是一个名为main的函数

```go
func main() {
        fmt.Println("Hello World")
}
```

这里的main函数会比较特殊，当运行一个可执行的Go程序时，所有的代码都会从这个入口函数开始执行。这段代码的第一行声明了一个名为main的、没有任何参数和返回值的函数。

花括号被用来标记函数体，Go要求所有的函数体都要被花括号包裹起来。

main中调用了一个名为Println的函数，这个函数位于Go标准库的fmt包中。为了在示例程序中使用fmt包定义的Println函数，实际上做了两步操作。

第一步是在源文件开始处通过import声明导入fmt包的包路径

```go
import "fmt"
```

第二步则是在main函数体中，通过fmt这个限定标识符调用Println函数。虽然两处都使用了"fmt"这个字面值，但这两处"fmt"字面值所代表的含义却是不一样的。

1. import "fmt" 一行中"fmt"代表的是包的的导入路径(import)，表示的是标准库下的fmt目录，整个import声明语句的含义是导入标准库fmt目录下的包

2. fmt.Println函数调用一行的"fmt"代表的则是包名

通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解import声明语句中"fmt"指的是包名，其实并非如此。

main函数体中之所以可以调用fmt包的Println函数，还有最后一个原因，就是Println函数名的首字母是大写的。在Go语言中，只有首字母为大写的标识符才是导出的，才能对包外的代码可见，如果是小写的，那么说明这个标识符仅限于声明它的包内可见。

另外，在Go语言中，main包不可以像标准库fmt包那样被导入

可以发现，代码中很少看到使用分号，这是因为在Go语言中是可以被省略的，编译器会自动插入分号。

现在来看看编译
`go build main.go`

这和gcc相似，一旦编译成功就会获得一个二进制可执行文件。下方语句同样可以执行

`go run main.go`

#### 基础语法

###### 变量声明

在编程语言中，为了方便操作内存特定位置的数据，**用一个特定的名字与位于特定位置的内存块绑定在一起**，这个名字被称为变量。

这不代表可以通过变量随意引用或修改内存，变量所绑定的内存区域要有一个明确的边界。也就是说，通过这样一个变量，究竟能操作4个字节内存还是8个字节内存又或是256个字节内存，编程语言的编译器或解释器要明确地知道。

那么又如何知道一个变量所能引用的内存区域边界？动态语言和静态语言有所不同。

动态语言的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。

而静态编程语言在这方面的"体验略差"。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了"变量声明"。通过变量声明，语言使用者可以显式告知编译器一个变量的边界信息。在具体实现层面，这个信息由变量的类型属性赋予。

Go语言作为静态编程语言，它沿袭了静态语言这一要求，使用变量之前要先进行变量声明。

通用方法是这样的

`var a int = 10`

这可以分为4个部分

1. var 是修饰变量声明的关键字

2. a 为变量名

3. int 为该变量类型

4. 10 是变量的初值

Go语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型前面。如果声明时没有赋初值，那么编译器会赋予这个类型的零值，例如:

`var a int` 

a的初值为int类型的零值: 0

什么是类型的零值？Go语言的每种原生类型都有它的默认值

| 内置原生类型                    | 默认值(零值) |
| ------------------------- | ------- |
| 所有整型类型                    | 0       |
| 浮点类型                      | 0.0     |
| 布尔类型                      | FALSE   |
| 字符串类型                     | ""      |
| 指针、借口、切片、channel、map和函数类型 | nil     |

另外，像数组、结构体这样复合类型变量的零值就是它们组成元素都为零值时的结果。

除了单独声明每个变量外，Go语言还提供了变量声明块(block)的语法形式，可以用一个var关键字将多个变量声明放在一起，像这样:

```go
var (
    a int = 128
    b int8 = 6
    s string = "hello"
    c rune = 'A'
    t boo = true
)
```

在这个变量声明块中，通过一个var关键字声明了5种不同类型的变量。而且，Go语言还支持一行变量声明中同时声明多个变量。

```go
var (
    a,b,c int = 5,6,7
    c,d,e rune = 'C','D','E'
)
```

除了通用的变量声明形式，还有两种

省略类型信息的声明:

在通用的变量声明的基础上，Go编译器允许省略变量声明中的类型信息，它的标准范式是

`var varName = intExpression`

比如下面就是一个省略类型信息的变量声明

`var b = 13`

那么Go编译器在遇到这样的变量声明后是如何确定变量的类型信息？

Go编译器会根据右侧变量初值自动推导出变量的类型，并给这个变量赋予初值所对应的默认类型。比如，整型值的默认类型int，浮点值的默认类型为float64，复数值的默认类型为complex128...

如果不接受默认类型，而是要显式地为变量指定类型，除了通用的声明形式，还可以通过显式类型转型达到目的

`var b = int32(13)`

这种方法只适用于变量声明的同时显示赋予变量初值的情况，下面这种没有初值的声明形式是不被允许的:

`var b`

结合多变量声明，可以使用这种办法声明多个不同类型的变量

`var a,b,c = 12, 'A',"hello"`

在这种变量声明中，声明了3个变量a、b和c，但它们分别具有不同的类型，分别为int、rune和string

在这种变量声明中，可以省去变量类型信息，但Go编译器会自动推导出类型信息。那是否还有更简化的变量声明形式？

**短变量声明**

现在甚至可以省去var关键字以及类型信息，它的标准范式是"varName := initExpression"

```go
a := 12
b := 'A'
c := "hello"
```

短变量声明将通用变量声明中的四个部分省去了两个，但它并没有使用赋值操作符"="，而是使用了短变量声明专用的":="。这个原理和上一种省略类型信息的声明方式一样，短变量声明中的变量类型也是由Go编译器自动推导出来的。

到目前为止，现在至少有3种变量声明形式了，要分清该使用哪一种得先知道一个概念:

###### **Go语言的两类变量**

通常来说，Go的变量可以分为两类： 一类是**包级变量**(package varible)，也就是在包级别可见的变量。如果是导出变量(大写字母开头)，那么这个包级变量也可以被视为全局变量。另一类则是**局部变量**(local varible)，也就是Go函数或方法内声明的变量，仅仅在函数或方法体内可见。

**包级变量的声明形式**

只能使用带有var关键字的变量声明形式，不能使用短变量声明形式，但在形式细节上可以有一定灵活度，这要从"变量声明是否延迟初始化"去分类考虑。

**声明并同时显式初始化**

```go
var ErrShortWrite = errors.New("short write")
var ErrShortBuffer = errors.New("short buffer")
var EOF = errors.New("EOF")
```

这个代码块里声明的变量都是io包的包级变量。在Go标准库中，对于变量声明的同时进行显式初始化的这类包级变量，实践中多使用这种省略类型信息的格式

`var varName = initExpression`

也可以显式指定类型

```go
// 第一种
var a = 13
var b int32= 17
var f float2 = 3.14


// 第二种
var a = 13
var b = int32(17)
var f = float32(3.14)
```

但更推荐如下的方式:

```go
var (
    a = 13
    b = int32(17)
    f = float32(3.14)
)
```

这里还有一个注意事项，就是声明聚类与就近原则。

Go 语言提供了变量声明块用来把多个的变量声明放在一起，并且在语法上也不会限制放置在 var 块中的声明类型。那就应该学会充分利用 var 变量声明块，让变量声明更规整，更具可读性，通常，会将同一类的变量声明放在一个 var 变量声明块中，不同类的声明放在不同的 var 声明块中，比如下面就是从标准库 net 包中摘取的两段变量声明代码：

```go
var (
    netGo  bool 
    netCgo bool 
)

var (
    aLongTimeAgo = time.Unix(1, 0)
    noDeadline = time.Time{}
    noCancel   = (chan struct{})(nil)
)
```

上面这两个 var 声明块各自声明了一类特定用途的包级变量

其实，可以将延迟初始化的变量声明放在一个 var 声明块 (比如上面的第一个 var 声明块)，然后将声明且显式初始化的变量放在另一个 var 块中（比如上面的第二个 var 声明块），这里称这种方式为“声明聚类”，声明聚类可以提升代码可读性。

使用静态编程语言的开发人员都知道，变量声明最佳实践中还有一条：**就近原则**。也就是说尽可能在靠近第一次使用变量的位置声明这个变量。就近原则实际上也是对变量的作用域最小化的一种实现手段。在 Go 标准库中也很容易找到符合就近原则的变量声明的例子，比如下面这段标准库 http 包中的代码就是这样：

```go
var ErrNoCookie = errors.New("http: named cookie not present")
func (r *Request) Cookie(name string) (*Cookie, error) {
    for _, c := range readCookies(r.Header, name) {
        return c, nil
    }
    return nil, ErrNoCookie
}
```

在这个代码块里，ErrNoCookie 这个变量在整个包中仅仅被用在了 Cookie 方法中，因此它被声明在紧邻 Cookie 方法定义的地方。如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合的。

**局部变量的声明形式**

这里也从“变量声明的时候是否延迟初始化”这个角度，对本地变量的声明形式进行分类说明。

对于**延迟初始化的局部变量声明**，采用通用的变量声明形式

省略类型信息的声明和短变量声明这两种“语法糖”变量声明形式都不支持变量的延迟初始化，因此对于这类局部变量，和包级变量一样，只能采用通用的变量声明形式：

`var err error`

对于**声明且显式初始化的局部变量**，建议使用短变量声明形式

短变量声明形式是局部变量最常用的声明形式，它遍布在 Go 标准库代码中。

```go
a := 17
f := 3.14
s := "hello, gopher!"
```

对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在":="右侧要做一个显式转型，以保持声明的一致性：

```go
a := int32(17)
f := float32(3.14)
s := []byte("hello, gopher!")
```

还要注意：尽量在分支控制时使用短变量声明形式。

分支控制应该是 Go 中短变量声明形式应用得最广泛的场景了。在编写 Go 代码时，很少单独声明用于分支控制语句中的变量，而是将它与 if、for 等控制语句通过短变量声明形式融合在一起，即在控制语句中直接声明用于控制语句代码块中的变量。

摘自 Go 标准库中的代码，strings 包的 LastIndexAny 方法很好地诠释了如何将短变量声明形式与分支控制语句融合在一起使用：

```go
// $GOROOT/src/strings/strings.go
func LastIndexAny(s, chars string) int {
    if chars == "" {
        // Avoid scanning all of s.
        return -1
    }
    if len(s) > 8 {
        // 作者注：在if条件控制语句中使用短变量声明形式声明了if代码块中要使用的变量as和isASCII
        if as, isASCII := makeASCIISet(chars); isASCII { 
            for i := len(s) - 1; i >= 0; i-- {
                if as.contains(s[i]) {
                    return i
                }
            }
            return -1
        }
    }
    for i := len(s); i > 0; { 
        // 作者注：在for循环控制语句中使用短变量声明形式声明了for代码块中要使用的变量c
        r, size := utf8.DecodeLastRuneInString(s[:i])
        i -= size
        for _, c := range chars {
            if r == c {
                return i
            }
        }
    }
    return -1
}
```

而且，短变量声明的这种融合的使用方式也体现出“就近”原则，让变量的作用域最小化。

另外，虽然良好的函数 / 方法设计都讲究“单一职责”，所以每个函数 / 方法规模都不大，很少要应用 var 块来聚类声明局部变量，但是如果在声明局部变量时遇到了适合聚类的应用场景，也应该毫不犹豫地使用 var 声明块来声明多于一个的局部变量，具体写法可以参考 Go 标准库 net 包中 resolveAddrList 方法：

```go
func (r *Resolver) resolveAddrList(ctx context.Context, op, network, 
                            addr string, hint Addr) (addrList, error) {
    ... ...
    var (
        tcp      *TCPAddr
        udp      *UDPAddr
        ip       *IPAddr
        wildcard bool
    )
   ... ...
}
```

#### 

#### Go的设计哲学(选看)

Go 语言致力于成为一门**简单**的语言，只有25个关键字，内置垃圾收集，降低开发人员的心智负担.首字母大小写决定可见性，无需通过额外关键字修饰。内置数组边界检查，极大减少了越界访问带来的安全隐患。...

**显式**是Go语言的第二个设计哲学

先拿C语言来说

```c
#include <stdio.h>

int main() {
    short int a = 5;

    int b = 8;
    long c = 0;

    c = a + b;
    printf("%ld\n", c);
}
```

可以看到上述代码中，变量a、b和c的类型均不相同，C语言编译器在编译c = a + b这一行时，会自动将短整型变量a和整型变量b，先转换为long类型然后相加，并将所得结果存储在long类型变量c中。那如果换成Go又是怎样的呢？

```go
package main

import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = a + b
    fmt.Printf("%d\n", c)
}
```

这段代码是不能通过编译的，必须要显式转换

`c = int64(a) + int64(b)`

这就是Go语言显式设计哲学的一个体现，不同类型变量是不能在一起混合计算的，这是因为Go希望开发人员明确知道自己在做什么，这与C语言的"信任程序员"原则完全不同，因此需要以显式的方式通过转型统一参与计算各个变量的类型。

除此之外，Go设计者所崇尚的显式哲学还直接决定了Go语言错误处理的形态: Go语言采用了显式的基于值比较的错误处理方案，函数/方法中的错误都会通过return语句显式地返回，并且通常调用者不能忽略对返回错误的处理。

第三个设计哲学是**组合**

这个设计哲学和各个程序之间的耦合有关系，Go不像C++、Java等主流面向对象语言，在Go中是找不到经典的面向对象语法元素、类型体系和继承机制的，Go推崇的是组合的设计哲学。

在其设计层面，Go设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括:

1. Go语言无类型层次体系，各类型之间相互独立，没有子类型的概念

2. 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的

3. 实现某个接口时，无需像Java那样采用特定关键字修饰。

4. 包之间是相互独立的，没有子包的概念

第四个设计哲学是**并发**

众所周知，CPU靠提高主频来改进性能，但这个做法已经遇到了瓶颈。主频提高导致CPU的功耗和发热量剧增，反过来制约了CPU性能的进一步提高。

在这种大背景下，Go设计者果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，Go放弃了传统的基于操作系统线程的并发模型，采用了用户层轻量级线程。

最后一个设计哲学是**面向工程**
