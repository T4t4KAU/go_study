## 认识Go语言

IDE: Goland

OS: Deepin Linux

#### 写在前面

先吹一波Go语言...

它是一种非常简单的语言，学习一周就可以编写一些简单、实用，而且质量不低的小程序。

它是生产力与性能的最佳结合。能在保持生产力的同时，大幅度提高性能。

它能给你带来快乐。相比C++，Go的开发体验有巨大提升。

现在来谈谈Go的历史和现状，毕竟这对我来说也是一门新语言，得对它有一个整体的认知。

Go的创始人有三位，分别是肯-汤普森(Unix之父)、罗伯-派克(UTF8编码设计者)和罗伯特-格瑞史莫。

由于当时谷歌内部主要使用C++语言构建各种系统，但C++的巨大复杂性、编译构建速度慢以及在编写服务端程序时对并发支持不足，让三位大佬感到不便。于是乎他们就想设计一门新的语言...

#### 认识Go程序的结构

用Go语言中编写一个可以打印"Hello World"的程序，只需要简单两步，一是创建文件夹，二是开始编写和运行。

首先创建一个文件夹存储编写的go代码

```shell
$ mkdir goprojects
$ cd goprojects/
$ mkdir helloworld
$ cd helloworld/
```

然后编写程序

在命名.go文件时不能使用下划线，有多个单词时直接将其连接起来就行了

```go
package main

import "fmt"

func main() {
        fmt.Println("Hello World")
}
```

```shell
$ go build main.go
$ ./main
Hello World
```

如上是命令行编译

现在回头看看结构

```go
package main
```

这一行代码定义了Go中的一个包package。包是Go语言的基本组成单元，通常使用单个的小写单词命名，一个Go程序本质上就是一组包的集合。所有Go代码都有自己隶属的包，在这里的"Hello World"示例的所有代码都在一个名为main的包中。main包在Go中是一个特殊的包，整个Go程序仅允许存在一个名为main的包

main包的主要代码是一个名为main的函数

```go
func main() {
        fmt.Println("Hello World")
}
```

这里的main函数会比较特殊，当运行一个可执行的Go程序时，所有的代码都会从这个入口函数开始执行。这段代码的第一行声明了一个名为main的、没有任何参数和返回值的函数。

花括号被用来标记函数体，Go要求所有的函数体都要被花括号包裹起来。

main中调用了一个名为Println的函数，这个函数位于Go标准库的fmt包中。为了在示例程序中使用fmt包定义的Println函数，实际上做了两步操作。

第一步是在源文件开始处通过import声明导入fmt包的包路径

```go
import "fmt"
```

第二步则是在main函数体中，通过fmt这个限定标识符调用Println函数。虽然两处都使用了"fmt"这个字面值，但这两处"fmt"字面值所代表的含义却是不一样的。

1. import "fmt" 一行中"fmt"代表的是包的的导入路径(import)，表示的是标准库下的fmt目录，整个import声明语句的含义是导入标准库fmt目录下的包

2. fmt.Println函数调用一行的"fmt"代表的则是包名

通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解import声明语句中"fmt"指的是包名，其实并非如此。

main函数体中之所以可以调用fmt包的Println函数，还有最后一个原因，就是Println函数名的首字母是大写的。在Go语言中，只有首字母为大写的标识符才是导出的，才能对包外的代码可见，如果是小写的，那么说明这个标识符仅限于声明它的包内可见。

另外，在Go语言中，main包不可以像标准库fmt包那样被导入

可以发现，代码中很少看到使用分号，这是因为在Go语言中是可以被省略的，编译器会自动插入分号。

现在来看看编译
`go build main.go`

这和gcc相似，一旦编译成功就会获得一个二进制可执行文件。下方语句同样可以执行

`go run main.go`

#### Go的设计哲学

Go 语言致力于成为一门**简单**的语言，只有25个关键字，内置垃圾收集，降低开发人员的心智负担.首字母大小写决定可见性，无需通过额外关键字修饰。内置数组边界检查，极大减少了越界访问带来的安全隐患。...

**显式**是Go语言的第二个设计哲学

先拿C语言来说

```c
#include <stdio.h>

int main() {
    short int a = 5;

    int b = 8;
    long c = 0;

    c = a + b;
    printf("%ld\n", c);
}
```

可以看到上述代码中，变量a、b和c的类型均不相同，C语言编译器在编译c = a + b这一行时，会自动将短整型变量a和整型变量b，先转换为long类型然后相加，并将所得结果存储在long类型变量c中。那如果换成Go又是怎样的呢？

```go
package main

import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = a + b
    fmt.Printf("%d\n", c)
}
```

这段代码是不能通过编译的，必须要显式转换

`c = int64(a) + int64(b)`

这就是Go语言显式设计哲学的一个体现，不同类型变量是不能在一起混合计算的，这是因为Go希望开发人员明确知道自己在做什么，这与C语言的"信任程序员"原则完全不同，因此需要以显式的方式通过转型统一参与计算各个变量的类型。

除此之外，Go设计者所崇尚的显式哲学还直接决定了Go语言错误处理的形态: Go语言采用了显式的基于值比较的错误处理方案，函数/方法中的错误都会通过return语句显式地返回，并且通常调用者不能忽略对返回错误的处理。

第三个设计哲学是**组合**

这个设计哲学和各个程序之间的耦合有关系，Go不像C++、Java等主流面向对象语言，在Go中是找不到经典的面向对象语法元素、类型体系和继承机制的，Go推崇的是组合的设计哲学。

在其设计层面，Go设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括:

1. Go语言无类型层次体系，各类型之间相互独立，没有子类型的概念

2. 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的

3. 实现某个接口时，无需像Java那样采用特定关键字修饰。

4. 包之间是相互独立的，没有子包的概念

第四个设计哲学是**并发**

众所周知，CPU靠提高主频来改进性能，但这个做法已经遇到了瓶颈。主频提高导致CPU的功耗和发热量剧增，反过来制约了CPU性能的进一步提高。

在这种大背景下，Go设计者果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，Go放弃了传统的基于操作系统线程的并发模型，采用了用户层轻量级线程。

最后一个设计哲学是**面向工程**
